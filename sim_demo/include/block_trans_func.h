#pragma once 

#include <vector>
#include <valarray>
#include <string>
#include "block_ode.h"

/*
	====================================================================================================================
	传递函数
			 num[m]*s^m + num[m-1]*s^(m-1) + num[m-2]*s^(m-2) + ... + num[1]*s + num[0]
	G(s) = ------------------------------------------------------------------------------
			 den[n]*s^n + den[n-1]*s^(n-1) + den[n-2]*s^(n-2) + ... + den[1]*s + den[0]
	注意:
		len(num) = m + 1
		len(den) = n + 1
	要求: n >= m

	将传递函数化为标准形式：
	令:
		k = num[m] / den[n]
		a = num / num[-1]
		b = den / den[-1]
	则:
			 s^m + a[m-1]*s^(m-1) + a[m-2]*s^(m-2) + ... + a[1]*s + a[0]
	G(s) = --------------------------------------------------------------- * k
			 s^n + b[n-1]*s^(n-1) + b[n-2]*s^(n-2) + ... + b[1]*s + b[0]
		len(a) = m
		len(b) = n
	====================================================================================================================

	实现方法请参考：
		http://lpsa.swarthmore.edu/Representations/SysRepTransformations/TF2SS.html
		首先将传递函数分解
		G' = k * G1 * G2
										1
	G1(s) = -------------------------------------------------------------
			 s^n + b[n-1]*s^(n-1) + b[n-2]*s^(n-2) + ... + b[1]*s + b[0]

			 s^m + a[m-1]*s^(m-1) + a[m-2]*s^(m-2) + ... + a[1]*s + a[0]
	G2(s) = -------------------------------------------------------------
										1
	将G1转化为微分方程：
		x0*(s^n + b[n-1]*s^(n-1) + b[n-2]*s^(n-2) + ... + b[1]*s + b[0]) = r
		d^n x0 + b[n-1]*d^{n-1} x0 + b[n-2]*d^{n-2} x0 + ... + b[1]d x0 + b[0] = r
	====================================================================================================================
	情况0：当分子阶数小于分母阶数时，转化为可控标准型为：
		\dot{x} = Ax + Bu
		y = Cx

		状态变量x，长度为n=len(den)-1
		x = | x0                         |
			| x1=x0'                     |
			| x2=x2'=x0''                |
			| ...                        |
			| x[n-1]=d^(n-1)/dt^(n-1) x0 |

		x' = | x1        |
			 | x2        |
			 | x3        |
			 | ..        |
			 | x[n-1]    |
			 | -b . x + u|

		A的大小为[n x n]
		A = |  0        1        0        ...    0      |         B =  | 0   |         C =  | a[0]   |
			|  0        0        1        ...    0      |              | 0   |              | a[1]   |
			|  0        0        0        ...    0      |              | 0   |              | ...    |
			|  ...      ...      ...      ...    ...    |              | ... |              | a[m-1] |
			|  ...      ...      ...      ...    ...    |              | ... |              | 1      |
			|  0        0        0        ...    1      |              | 0   |              | ...    |
			| -b[0]    -b[1]    -b[2]     ...   -b[n-1] |              | 1   |              | 0      |
		计算过程A仅保存最后一行，B不保存

	====================================================================================================================
	情况1：当分子阶数等于分母阶数(m=n)时：
		\dot{x} = Ax + Bu
		y = Cx + Du
		AB同上
			C =  | a[0]-b[0]     |
				 | a[1]-b[1]     |
				 | ...           |
				 | a[n-1]-b[n-1] |
			D = [1]
 */

//TransFunc 传递函数
class BlockTransFunc : public BlockOde
{
protected:
	// 传递函数分子分母下标对应于s的次数，初始化时存储，求解过程中不使用
	// 注意：输入传递函数时，通常为[1,2,3]/[4,5,6]这种从高次到低次的形式
	//      但是求解时，必须转换为[3,2,1]/[6,5,4]这种从低次到高次的形式，更方便求解
	std::vector<double> _num;	// 分子 a, 长度m+1
	std::vector<double> _den;	// 分母 b, 长度n+1

	double _k = 1.0;		// 增益
	array_d _a_last_row;	// A矩阵的最后一行
	array_d _c;				// C矩阵（一列）

public:
	BlockTransFunc()
	{
		_type = "BlockTransFunc";
	}

	bool init(const json& cfg) override;
	array_d derivative(const double t, const array_d& x) override;
	void do_output(const double t, const array_d& x, const array_d& x_d) override;
	std::string to_str() const;
};

